<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Small Body Geophysical Analysis Tool (SBGAT): Adjacency_List&lt; T1, T2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Small Body Geophysical Analysis Tool (SBGAT)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_adjacency___list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Adjacency_List&lt; T1, T2 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class template. This is a template for a graph of vertices and edges of types T1 and T2, respectively.  
 <a href="class_adjacency___list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class.  <a href="struct_adjacency___list_1_1vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36f797555285f40b0320eb745774e127"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td></tr>
<tr class="memdesc:a36f797555285f40b0320eb745774e127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class.  <a href="#a36f797555285f40b0320eb745774e127">More...</a><br /></td></tr>
<tr class="separator:a36f797555285f40b0320eb745774e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td></tr>
<tr class="memdesc:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge type definition:  <a href="#ad2d0ad868f211a253fc7f5fc09f29b65">More...</a><br /></td></tr>
<tr class="separator:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td></tr>
<tr class="memdesc:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexmap type definition:  <a href="#a5f1ff6746e887afb9fd3eb33f0692e84">More...</a><br /></td></tr>
<tr class="separator:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a730c002bfea9ee4745be4b11e5ca10db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a730c002bfea9ee4745be4b11e5ca10db">Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a730c002bfea9ee4745be4b11e5ca10db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a730c002bfea9ee4745be4b11e5ca10db">More...</a><br /></td></tr>
<tr class="separator:a730c002bfea9ee4745be4b11e5ca10db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e980e39f44ca8bfa305e0b009b72200"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1e980e39f44ca8bfa305e0b009b72200">~Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a1e980e39f44ca8bfa305e0b009b72200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1e980e39f44ca8bfa305e0b009b72200">More...</a><br /></td></tr>
<tr class="separator:a1e980e39f44ca8bfa305e0b009b72200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9a43d2d171801e35c1f45ae6baca93"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93">getnumv</a> ()</td></tr>
<tr class="memdesc:afc9a43d2d171801e35c1f45ae6baca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a>  <a href="#afc9a43d2d171801e35c1f45ae6baca93">More...</a><br /></td></tr>
<tr class="separator:afc9a43d2d171801e35c1f45ae6baca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2da43c411ed0a239798a2a3c883f24"><td class="memItemLeft" align="right" valign="top">T2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24">getedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:aeb2da43c411ed0a239798a2a3c883f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a>  <a href="#aeb2da43c411ed0a239798a2a3c883f24">More...</a><br /></td></tr>
<tr class="separator:aeb2da43c411ed0a239798a2a3c883f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="memItemLeft" align="right" valign="top">std::set&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193">getneighbors</a> (T1 src)</td></tr>
<tr class="memdesc:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193" title="std::set&lt;T1&gt; getneighbors(T1 src) ">getneighbors(T1 src)</a>  <a href="#a59ad0070d2f6fcc2d3b5d86a616ff193">More...</a><br /></td></tr>
<tr class="separator:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940d2076901a50659ca83894b945218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218">edgeexist</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a4940d2076901a50659ca83894b945218"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a>  <a href="#a4940d2076901a50659ca83894b945218">More...</a><br /></td></tr>
<tr class="separator:a4940d2076901a50659ca83894b945218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b">vertexexists</a> (T1 node)</td></tr>
<tr class="memdesc:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a>  <a href="#a5fef72d4ecb4cfa5438a653e1e58e91b">More...</a><br /></td></tr>
<tr class="separator:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c55c71c959b90164a334687a76cc2"><td class="memItemLeft" align="right" valign="top">T1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2">getvertex</a> (T1 node)</td></tr>
<tr class="memdesc:a183c55c71c959b90164a334687a76cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a>  <a href="#a183c55c71c959b90164a334687a76cc2">More...</a><br /></td></tr>
<tr class="separator:a183c55c71c959b90164a334687a76cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4579e85308ada2431895a71c5f7c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7">displaygraph</a> (uint16_t w)</td></tr>
<tr class="memdesc:a8bd4579e85308ada2431895a71c5f7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a>  <a href="#a8bd4579e85308ada2431895a71c5f7c7">More...</a><br /></td></tr>
<tr class="separator:a8bd4579e85308ada2431895a71c5f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae810d0d613e5f2b233179b09a4fa0305"><td class="memItemLeft" align="right" valign="top">std::set&lt; T2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305">get_edges</a> ()</td></tr>
<tr class="memdesc:ae810d0d613e5f2b233179b09a4fa0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305" title="std::set&lt;T2&gt; get_edges() ">get_edges()</a>  <a href="#ae810d0d613e5f2b233179b09a4fa0305">More...</a><br /></td></tr>
<tr class="separator:ae810d0d613e5f2b233179b09a4fa0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="memItemLeft" align="right" valign="top">std::set&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696">get_vertices</a> ()</td></tr>
<tr class="memdesc:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696" title="std::set&lt;T1&gt; get_vertices() ">get_vertices()</a>  <a href="#a2cbaca74a056c9b3d2ad6558fccdd696">More...</a><br /></td></tr>
<tr class="separator:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dd59802c4a04906aec8cc0703254e8"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8">dfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a18dd59802c4a04906aec8cc0703254e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a>  <a href="#a18dd59802c4a04906aec8cc0703254e8">More...</a><br /></td></tr>
<tr class="separator:a18dd59802c4a04906aec8cc0703254e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c640eaabccc946280cac85aa6f5998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36c640eaabccc946280cac85aa6f5998">ddfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a36c640eaabccc946280cac85aa6f5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">void ddfs  <a href="#a36c640eaabccc946280cac85aa6f5998">More...</a><br /></td></tr>
<tr class="separator:a36c640eaabccc946280cac85aa6f5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc">setdirected</a> (bool <a class="el" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a>)</td></tr>
<tr class="memdesc:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a>  <a href="#a463a0f885dd38f2d49b928bc12b1cdcc">More...</a><br /></td></tr>
<tr class="separator:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae736daafd94362c6490babb98babb751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751">addedge</a> (T1 src, T1 dest, T2 link)</td></tr>
<tr class="memdesc:ae736daafd94362c6490babb98babb751"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a>  <a href="#ae736daafd94362c6490babb98babb751">More...</a><br /></td></tr>
<tr class="separator:ae736daafd94362c6490babb98babb751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d7868abec7c406ac4f91c1baf8663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663">addvertex</a> (T1 node)</td></tr>
<tr class="memdesc:aa12d7868abec7c406ac4f91c1baf8663"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a>  <a href="#aa12d7868abec7c406ac4f91c1baf8663">More...</a><br /></td></tr>
<tr class="separator:aa12d7868abec7c406ac4f91c1baf8663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ebd0a5b83448088959d1173fba710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710">removeedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a472ebd0a5b83448088959d1173fba710"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a>  <a href="#a472ebd0a5b83448088959d1173fba710">More...</a><br /></td></tr>
<tr class="separator:a472ebd0a5b83448088959d1173fba710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794c310f08f59d85cb57b5d33caa667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667">removevertex</a> (T1 node)</td></tr>
<tr class="memdesc:a1794c310f08f59d85cb57b5d33caa667"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a>  <a href="#a1794c310f08f59d85cb57b5d33caa667">More...</a><br /></td></tr>
<tr class="separator:a1794c310f08f59d85cb57b5d33caa667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3bdcdffd1d958c299effaf92662884f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">_dfs</a> (T1 src, T1 dest, std::deque&lt; T1 &gt; &amp;dq, bool &amp;found)</td></tr>
<tr class="memdesc:a3bdcdffd1d958c299effaf92662884f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2" title="void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) ">_dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found)</a>  <a href="#a3bdcdffd1d958c299effaf92662884f2">More...</a><br /></td></tr>
<tr class="separator:a3bdcdffd1d958c299effaf92662884f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f717a791cb785079f31f513b2aa92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a643f717a791cb785079f31f513b2aa92">Adjacency_List</a> (const <a class="el" href="class_adjacency___list.html">Adjacency_List</a> &amp;rhs)</td></tr>
<tr class="separator:a643f717a791cb785079f31f513b2aa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61efd38d84e8f713ea321d800bdca03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a61efd38d84e8f713ea321d800bdca03f">operator=</a> (const <a class="el" href="class_adjacency___list.html">Adjacency_List</a> &amp;rhs)</td></tr>
<tr class="separator:a61efd38d84e8f713ea321d800bdca03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab4154ab5baaf2c35eb12fdf4d2cc3887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a></td></tr>
<tr class="separator:ab4154ab5baaf2c35eb12fdf4d2cc3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ceab755c148a8f0bdb6f8c3ccfcc7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a></td></tr>
<tr class="separator:a92ceab755c148a8f0bdb6f8c3ccfcc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T1, class T2&gt;<br />
class Adjacency_List&lt; T1, T2 &gt;</h3>

<p><a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class template. This is a template for a graph of vertices and edges of types T1 and T2, respectively. </p>
<p>Adjacency_List.hh </p><dl class="section author"><dt>Author</dt><dd>Andrew French </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan 8, 2014</dd></dl>
<p>The <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class is a container class that stores information in the form of a graph, either directed or undirected, through locally defined vertices and edges. This class supports dynamic insertion and removal of both vertices and edges, contrary to popular implementations. A basic depth-firsth-algorithm is also included, providing simple path-finding between vertices, so long as the graph is connected. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad2d0ad868f211a253fc7f5fc09f29b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d0ad868f211a253fc7f5fc09f29b65">&#9670;&nbsp;</a></span>edge</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge type definition: </p>
<p>pair of type T2 object and pointer to a vertex </p>

</div>
</div>
<a id="a36f797555285f40b0320eb745774e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f797555285f40b0320eb745774e127">&#9670;&nbsp;</a></span>vertex_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>  <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class. </p>
<p>Each vertex of type T1 contains a list of pointers to the vertices adjacent to it, paired with an object of type T2. Each vertex also contains a boolean that is used in the search algorithms. </p>

</div>
</div>
<a id="a5f1ff6746e887afb9fd3eb33f0692e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1ff6746e887afb9fd3eb33f0692e84">&#9670;&nbsp;</a></span>vertexmap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexmap type definition: </p>
<p>This is the all encompassing data structure. A pointer to each vertex is stored in a map. A map was chosen for its fast (O(1)) access and (O(log(n))) search methods (i.e. std::find()). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a730c002bfea9ee4745be4b11e5ca10db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c002bfea9ee4745be4b11e5ca10db">&#9670;&nbsp;</a></span>Adjacency_List() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Default constructor: creates empty undirected graph. </p>

</div>
</div>
<a id="a1e980e39f44ca8bfa305e0b009b72200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e980e39f44ca8bfa305e0b009b72200">&#9670;&nbsp;</a></span>~Adjacency_List()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::~<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a643f717a791cb785079f31f513b2aa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643f717a791cb785079f31f513b2aa92">&#9670;&nbsp;</a></span>Adjacency_List() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bdcdffd1d958c299effaf92662884f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdcdffd1d958c299effaf92662884f2">&#9670;&nbsp;</a></span>_dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::_dfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2" title="void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) ">_dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found)</a> </p>
<p>Recursively defined depth-first-search algorithm. The path found is stored in the deque. If no path exists, the function will not modify the dq (i.e. it will remain empty if it was passed in empty).</p>
<p>Neccesary conditions for path retrieval:</p>
<p>1) Graph must be connected (path must exist between src &amp; dest)</p>
<p>Shortest path gaurenteed when:</p>
<p>1) Only one path exists &ndash; different algorithm can be implemented to accomodate multiple paths &ndash; a variation of breadth-first-search</p>
<p>** This will work for all trees! </p>

</div>
</div>
<a id="ae736daafd94362c6490babb98babb751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae736daafd94362c6490babb98babb751">&#9670;&nbsp;</a></span>addedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a> </p>
<p>Add edge between two vertices, if both exist. </p>

</div>
</div>
<a id="aa12d7868abec7c406ac4f91c1baf8663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12d7868abec7c406ac4f91c1baf8663">&#9670;&nbsp;</a></span>addvertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a> </p>
<p>Add vertex to graph. </p>

</div>
</div>
<a id="a36c640eaabccc946280cac85aa6f5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c640eaabccc946280cac85aa6f5998">&#9670;&nbsp;</a></span>ddfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::ddfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void ddfs </p>
<p>double ended (2-way) depth-first-search. Not yet implemented.</p>
<p>Advantages: faster searches for large graphs </p>

</div>
</div>
<a id="a18dd59802c4a04906aec8cc0703254e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18dd59802c4a04906aec8cc0703254e8">&#9670;&nbsp;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::dfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a> </p>
<p>Wrapper around _dfs (depth-first-search) algorithm that provides a cleaner user interface. See _dfs in the private section to view the algorithm implementation.</p>
<p>This function returns a path between two vertices if one exists. If no path exists, the dq output will be empty, which can be checked externally using dq.empty(). If more than one path exists, there is NO guarantee that the path found will be the shorted path.</p>
<p>Note: std::stack can be used in place of std::deque for less overhead however the deque comes with an iterator. this is an easy fix if needed later on. </p>

</div>
</div>
<a id="a8bd4579e85308ada2431895a71c5f7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd4579e85308ada2431895a71c5f7c7">&#9670;&nbsp;</a></span>displaygraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::displaygraph </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a> </p>
<p>Display graph to console. Parameter w determines setw formatting. Could overload &lt;&lt; operator </p>

</div>
</div>
<a id="a4940d2076901a50659ca83894b945218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4940d2076901a50659ca83894b945218">&#9670;&nbsp;</a></span>edgeexist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::edgeexist </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a> </p>
<p>Determine if an edge exists between two vertices. To prevent runtime errors this should ALWAYS be called before <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge()</a>. </p>

</div>
</div>
<a id="ae810d0d613e5f2b233179b09a4fa0305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae810d0d613e5f2b233179b09a4fa0305">&#9670;&nbsp;</a></span>get_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::get_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305" title="std::set&lt;T2&gt; get_edges() ">get_edges()</a> </p>
<p>Returns a set storing all the existing edges </p>

</div>
</div>
<a id="a2cbaca74a056c9b3d2ad6558fccdd696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbaca74a056c9b3d2ad6558fccdd696">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696" title="std::set&lt;T1&gt; get_vertices() ">get_vertices()</a> </p>
<p>Returns a set storing all the existing vertices </p>

</div>
</div>
<a id="aeb2da43c411ed0a239798a2a3c883f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2da43c411ed0a239798a2a3c883f24">&#9670;&nbsp;</a></span>getedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a> </p>
<p>Return edge between two vertices, if one exists. </p>

</div>
</div>
<a id="a59ad0070d2f6fcc2d3b5d86a616ff193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ad0070d2f6fcc2d3b5d86a616ff193">&#9670;&nbsp;</a></span>getneighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getneighbors </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193" title="std::set&lt;T1&gt; getneighbors(T1 src) ">getneighbors(T1 src)</a> </p>
<p>Return set of src's neighbors, if src exists. </p>

</div>
</div>
<a id="afc9a43d2d171801e35c1f45ae6baca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9a43d2d171801e35c1f45ae6baca93">&#9670;&nbsp;</a></span>getnumv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getnumv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a> </p>
<p>Return the number of vertices. </p>

</div>
</div>
<a id="a183c55c71c959b90164a334687a76cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c55c71c959b90164a334687a76cc2">&#9670;&nbsp;</a></span>getvertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a> </p>
<p>Return vertex from graph, if it exists </p>

</div>
</div>
<a id="a61efd38d84e8f713ea321d800bdca03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61efd38d84e8f713ea321d800bdca03f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a472ebd0a5b83448088959d1173fba710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472ebd0a5b83448088959d1173fba710">&#9670;&nbsp;</a></span>removeedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removeedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a> </p>
<p>Remove edge from graph. </p>

</div>
</div>
<a id="a1794c310f08f59d85cb57b5d33caa667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1794c310f08f59d85cb57b5d33caa667">&#9670;&nbsp;</a></span>removevertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removevertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a> </p>
<p>Remove vertex, and all associated edges, from graph. </p>

</div>
</div>
<a id="a463a0f885dd38f2d49b928bc12b1cdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a0f885dd38f2d49b928bc12b1cdcc">&#9670;&nbsp;</a></span>setdirected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::setdirected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isdirected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a> </p>
<p>Set the directedness of the graph. Default is undirected (false) </p>

</div>
</div>
<a id="a5fef72d4ecb4cfa5438a653e1e58e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fef72d4ecb4cfa5438a653e1e58e91b">&#9670;&nbsp;</a></span>vertexexists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::vertexexists </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a> </p>
<p>Check if vertex is in graph </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a92ceab755c148a8f0bdb6f8c3ccfcc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ceab755c148a8f0bdb6f8c3ccfcc7f">&#9670;&nbsp;</a></span>isdirected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::isdirected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4154ab5baaf2c35eb12fdf4d2cc3887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4154ab5baaf2c35eb12fdf4d2cc3887">&#9670;&nbsp;</a></span>vmap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a> <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::vmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/bbercovici/GDrive/CUBoulder/Research/code/SBGAT/SbgatCore/include/<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
