<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Small Body Geophysical Analysis Tool (SBGAT): Adjacency_List&lt; T1, T2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Small Body Geophysical Analysis Tool (SBGAT)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_adjacency___list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Adjacency_List&lt; T1, T2 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html">Adjacency_List</a> graph class.  <a href="struct_adjacency___list_1_1vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36f797555285f40b0320eb745774e127"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td></tr>
<tr class="memdesc:a36f797555285f40b0320eb745774e127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html">Adjacency_List</a> graph class.  <a href="#a36f797555285f40b0320eb745774e127">More...</a><br /></td></tr>
<tr class="separator:a36f797555285f40b0320eb745774e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td></tr>
<tr class="memdesc:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge type definition:  <a href="#ad2d0ad868f211a253fc7f5fc09f29b65">More...</a><br /></td></tr>
<tr class="separator:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td></tr>
<tr class="memdesc:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexmap type definition:  <a href="#a5f1ff6746e887afb9fd3eb33f0692e84">More...</a><br /></td></tr>
<tr class="separator:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a730c002bfea9ee4745be4b11e5ca10db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a730c002bfea9ee4745be4b11e5ca10db">Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a730c002bfea9ee4745be4b11e5ca10db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a730c002bfea9ee4745be4b11e5ca10db">More...</a><br /></td></tr>
<tr class="separator:a730c002bfea9ee4745be4b11e5ca10db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e980e39f44ca8bfa305e0b009b72200"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1e980e39f44ca8bfa305e0b009b72200">~Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a1e980e39f44ca8bfa305e0b009b72200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1e980e39f44ca8bfa305e0b009b72200">More...</a><br /></td></tr>
<tr class="separator:a1e980e39f44ca8bfa305e0b009b72200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9a43d2d171801e35c1f45ae6baca93"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93">getnumv</a> ()</td></tr>
<tr class="memdesc:afc9a43d2d171801e35c1f45ae6baca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a>  <a href="#afc9a43d2d171801e35c1f45ae6baca93">More...</a><br /></td></tr>
<tr class="separator:afc9a43d2d171801e35c1f45ae6baca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2da43c411ed0a239798a2a3c883f24"><td class="memItemLeft" align="right" valign="top">T2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24">getedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:aeb2da43c411ed0a239798a2a3c883f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a>  <a href="#aeb2da43c411ed0a239798a2a3c883f24">More...</a><br /></td></tr>
<tr class="separator:aeb2da43c411ed0a239798a2a3c883f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="memItemLeft" align="right" valign="top">std::set&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193">getneighbors</a> (T1 src)</td></tr>
<tr class="memdesc:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193" title="std::set&lt;T1&gt; getneighbors(T1 src) ">getneighbors(T1 src)</a>  <a href="#a59ad0070d2f6fcc2d3b5d86a616ff193">More...</a><br /></td></tr>
<tr class="separator:a59ad0070d2f6fcc2d3b5d86a616ff193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940d2076901a50659ca83894b945218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218">edgeexist</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a4940d2076901a50659ca83894b945218"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a>  <a href="#a4940d2076901a50659ca83894b945218">More...</a><br /></td></tr>
<tr class="separator:a4940d2076901a50659ca83894b945218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b">vertexexists</a> (T1 node)</td></tr>
<tr class="memdesc:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a>  <a href="#a5fef72d4ecb4cfa5438a653e1e58e91b">More...</a><br /></td></tr>
<tr class="separator:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c55c71c959b90164a334687a76cc2"><td class="memItemLeft" align="right" valign="top">T1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2">getvertex</a> (T1 node)</td></tr>
<tr class="memdesc:a183c55c71c959b90164a334687a76cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a>  <a href="#a183c55c71c959b90164a334687a76cc2">More...</a><br /></td></tr>
<tr class="separator:a183c55c71c959b90164a334687a76cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4579e85308ada2431895a71c5f7c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7">displaygraph</a> (uint16_t w)</td></tr>
<tr class="memdesc:a8bd4579e85308ada2431895a71c5f7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a>  <a href="#a8bd4579e85308ada2431895a71c5f7c7">More...</a><br /></td></tr>
<tr class="separator:a8bd4579e85308ada2431895a71c5f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae810d0d613e5f2b233179b09a4fa0305"><td class="memItemLeft" align="right" valign="top">std::set&lt; T2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305">get_edges</a> ()</td></tr>
<tr class="memdesc:ae810d0d613e5f2b233179b09a4fa0305"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305" title="std::set&lt;T2&gt; get_edges() ">get_edges()</a>  <a href="#ae810d0d613e5f2b233179b09a4fa0305">More...</a><br /></td></tr>
<tr class="separator:ae810d0d613e5f2b233179b09a4fa0305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="memItemLeft" align="right" valign="top">std::set&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696">get_vertices</a> ()</td></tr>
<tr class="memdesc:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696" title="std::set&lt;T1&gt; get_vertices() ">get_vertices()</a>  <a href="#a2cbaca74a056c9b3d2ad6558fccdd696">More...</a><br /></td></tr>
<tr class="separator:a2cbaca74a056c9b3d2ad6558fccdd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dd59802c4a04906aec8cc0703254e8"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8">dfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a18dd59802c4a04906aec8cc0703254e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a>  <a href="#a18dd59802c4a04906aec8cc0703254e8">More...</a><br /></td></tr>
<tr class="separator:a18dd59802c4a04906aec8cc0703254e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c640eaabccc946280cac85aa6f5998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36c640eaabccc946280cac85aa6f5998">ddfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a36c640eaabccc946280cac85aa6f5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">void ddfs  <a href="#a36c640eaabccc946280cac85aa6f5998">More...</a><br /></td></tr>
<tr class="separator:a36c640eaabccc946280cac85aa6f5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc">setdirected</a> (bool <a class="el" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a>)</td></tr>
<tr class="memdesc:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a>  <a href="#a463a0f885dd38f2d49b928bc12b1cdcc">More...</a><br /></td></tr>
<tr class="separator:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae736daafd94362c6490babb98babb751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751">addedge</a> (T1 src, T1 dest, T2 link)</td></tr>
<tr class="memdesc:ae736daafd94362c6490babb98babb751"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a>  <a href="#ae736daafd94362c6490babb98babb751">More...</a><br /></td></tr>
<tr class="separator:ae736daafd94362c6490babb98babb751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d7868abec7c406ac4f91c1baf8663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663">addvertex</a> (T1 node)</td></tr>
<tr class="memdesc:aa12d7868abec7c406ac4f91c1baf8663"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a>  <a href="#aa12d7868abec7c406ac4f91c1baf8663">More...</a><br /></td></tr>
<tr class="separator:aa12d7868abec7c406ac4f91c1baf8663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ebd0a5b83448088959d1173fba710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710">removeedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a472ebd0a5b83448088959d1173fba710"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a>  <a href="#a472ebd0a5b83448088959d1173fba710">More...</a><br /></td></tr>
<tr class="separator:a472ebd0a5b83448088959d1173fba710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794c310f08f59d85cb57b5d33caa667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667">removevertex</a> (T1 node)</td></tr>
<tr class="memdesc:a1794c310f08f59d85cb57b5d33caa667"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a>  <a href="#a1794c310f08f59d85cb57b5d33caa667">More...</a><br /></td></tr>
<tr class="separator:a1794c310f08f59d85cb57b5d33caa667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3bdcdffd1d958c299effaf92662884f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">_dfs</a> (T1 src, T1 dest, std::deque&lt; T1 &gt; &amp;dq, bool &amp;found)</td></tr>
<tr class="memdesc:a3bdcdffd1d958c299effaf92662884f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2" title="void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) ">_dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found)</a>  <a href="#a3bdcdffd1d958c299effaf92662884f2">More...</a><br /></td></tr>
<tr class="separator:a3bdcdffd1d958c299effaf92662884f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f717a791cb785079f31f513b2aa92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a643f717a791cb785079f31f513b2aa92">Adjacency_List</a> (const <a class="el" href="class_adjacency___list.html">Adjacency_List</a> &amp;rhs)</td></tr>
<tr class="separator:a643f717a791cb785079f31f513b2aa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61efd38d84e8f713ea321d800bdca03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a61efd38d84e8f713ea321d800bdca03f">operator=</a> (const <a class="el" href="class_adjacency___list.html">Adjacency_List</a> &amp;rhs)</td></tr>
<tr class="separator:a61efd38d84e8f713ea321d800bdca03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab4154ab5baaf2c35eb12fdf4d2cc3887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a></td></tr>
<tr class="separator:ab4154ab5baaf2c35eb12fdf4d2cc3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ceab755c148a8f0bdb6f8c3ccfcc7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a></td></tr>
<tr class="separator:a92ceab755c148a8f0bdb6f8c3ccfcc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T1, class T2&gt;<br />
class Adjacency_List&lt; T1, T2 &gt;</h3>


<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00042">42</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad2d0ad868f211a253fc7f5fc09f29b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d0ad868f211a253fc7f5fc09f29b65">&#9670;&nbsp;</a></span>edge</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge type definition: </p>
<p>pair of type T2 object and pointer to a vertex </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00075">75</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>

</div>
</div>
<a id="a36f797555285f40b0320eb745774e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f797555285f40b0320eb745774e127">&#9670;&nbsp;</a></span>vertex_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>  <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex type definition for the <a class="el" href="class_adjacency___list.html">Adjacency_List</a> graph class. </p>
<p>Each vertex of type T1 contains a list of pointers to the vertices adjacent to it, paired with an object of type T2. Each vertex also contains a boolean that is used in the search algorithms. </p>

</div>
</div>
<a id="a5f1ff6746e887afb9fd3eb33f0692e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1ff6746e887afb9fd3eb33f0692e84">&#9670;&nbsp;</a></span>vertexmap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexmap type definition: </p>
<p>This is the all encompassing data structure. A pointer to each vertex is stored in a map. A map was chosen for its fast (O(1)) access and (O(log(n))) search methods (i.e. std::find()). </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00085">85</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a730c002bfea9ee4745be4b11e5ca10db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c002bfea9ee4745be4b11e5ca10db">&#9670;&nbsp;</a></span>Adjacency_List() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Default constructor: creates empty undirected graph. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00092">92</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                     {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        this-&gt;<a class="code" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a> = <span class="keyword">false</span>;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_a92ceab755c148a8f0bdb6f8c3ccfcc7f"><div class="ttname"><a href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">Adjacency_List::isdirected</a></div><div class="ttdeci">bool isdirected</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00525">Adjacency_List.hpp:525</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e980e39f44ca8bfa305e0b009b72200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e980e39f44ca8bfa305e0b009b72200">&#9670;&nbsp;</a></span>~Adjacency_List()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::~<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00099">99</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                      {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="comment">// free memory allocated to vertices</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">for</span> (it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <span class="keyword">delete</span> it-&gt;second;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a643f717a791cb785079f31f513b2aa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643f717a791cb785079f31f513b2aa92">&#9670;&nbsp;</a></span>Adjacency_List() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bdcdffd1d958c299effaf92662884f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdcdffd1d958c299effaf92662884f2">&#9670;&nbsp;</a></span>_dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::_dfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2" title="void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) ">_dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found)</a> </p>
<p>Recursively defined depth-first-search algorithm. The path found is stored in the deque. If no path exists, the function will not modify the dq (i.e. it will remain empty if it was passed in empty).</p>
<p>Neccesary conditions for path retrieval:</p>
<p>1) Graph must be connected (path must exist between src &amp; dest)</p>
<p>Shortest path gaurenteed when:</p>
<p>1) Only one path exists &ndash; different algorithm can be implemented to accomodate multiple paths &ndash; a variation of breadth-first-search</p>
<p>** This will work for all trees! </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00546">546</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                                                              {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator adjIt;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        <span class="comment">// mark source as identified</span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        it-&gt;second-&gt;indentified = <span class="keyword">true</span>;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="comment">// for all edges in adjacency list</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end();</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                ++adjIt) {</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            <span class="comment">// if destination, push dest and src into queue and return</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            <span class="comment">// path found!</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == dest) {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                dq.push_front(dest);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;                dq.push_front(src);</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                found = <span class="keyword">true</span>;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                <span class="keywordflow">return</span>;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                <span class="comment">// skip edges back to self</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == src) {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                <span class="comment">//... do nothing ...</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                <span class="comment">// skip previously indentified edges</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;indentified == <span class="keyword">true</span>) {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                <span class="comment">//... do nothing ...</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                <span class="comment">// recursively call _dfs on adjacent vertices</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                <a class="code" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">_dfs</a>(adjIt-&gt;second-&gt;data, dest, dq, found);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                <span class="comment">// if dest has been found, push entire path into queue</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;                <span class="keywordflow">if</span> (found == <span class="keyword">true</span>) {</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                    dq.push_front(src);</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                }</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            }</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        }</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_a3bdcdffd1d958c299effaf92662884f2"><div class="ttname"><a href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">Adjacency_List::_dfs</a></div><div class="ttdeci">void _dfs(T1 src, T1 dest, std::deque&lt; T1 &gt; &amp;dq, bool &amp;found)</div><div class="ttdoc">void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) </div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00546">Adjacency_List.hpp:546</a></div></div>
<div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae736daafd94362c6490babb98babb751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae736daafd94362c6490babb98babb751">&#9670;&nbsp;</a></span>addedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a> </p>
<p>Add edge between two vertices, if both exist. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00402">402</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                                           {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator src_it, dest_it;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        src_it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        dest_it = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(dest));</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <span class="comment">// could add check for edge existence here if worried about adding</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="comment">// multiple edges between vertices</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="comment">// could also check for edge uniqueness to allow for multiple edges</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        <span class="comment">// between vertices so long as they contain differet values</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="comment">// check that both vertices exist</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">if</span> (src_it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Warning Adjacency_List::addedge(). Source vertex &quot;</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                      &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; does not exist! Edge was not added!\n&quot;</span>;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dest_it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Warning Adjacency_List::addedge(). Destination vertex &quot;</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                      &lt;&lt; dest &lt;&lt; <span class="stringliteral">&quot; does not exist! Edge was not added!\n&quot;</span>;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            <span class="comment">// add edge</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            vertex *from = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src)-&gt;second);</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            vertex *to   = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(dest)-&gt;second);</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            <a class="code" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a> e1 = std::make_pair(link, to);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            from-&gt;adj.push_back(e1);</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            <span class="comment">// if undirected, add &#39;other&#39; edge</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a>) {</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                <a class="code" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a> e2 = std::make_pair(link, from);</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                to-&gt;adj.push_back(e2);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        }</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ad2d0ad868f211a253fc7f5fc09f29b65"><div class="ttname"><a href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">Adjacency_List::edge</a></div><div class="ttdeci">std::pair&lt; T2, vertex * &gt; edge</div><div class="ttdoc">edge type definition: </div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00075">Adjacency_List.hpp:75</a></div></div>
<div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
<div class="ttc" id="class_adjacency___list_html_a92ceab755c148a8f0bdb6f8c3ccfcc7f"><div class="ttname"><a href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">Adjacency_List::isdirected</a></div><div class="ttdeci">bool isdirected</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00525">Adjacency_List.hpp:525</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa12d7868abec7c406ac4f91c1baf8663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12d7868abec7c406ac4f91c1baf8663">&#9670;&nbsp;</a></span>addvertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a> </p>
<p>Add vertex to graph. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00444">444</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                            {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin();</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(node);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        <span class="comment">// if vertex does not already exist, add it</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        <span class="keywordflow">if</span> (it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            vertex *v;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            v = <span class="keyword">new</span> vertex(node);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>[node] = v;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            <span class="keywordflow">return</span>;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Warning Adjacency_List::addvertex(). Vertex &quot;</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                  &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; already exists!\n&quot;</span>;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36c640eaabccc946280cac85aa6f5998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c640eaabccc946280cac85aa6f5998">&#9670;&nbsp;</a></span>ddfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::ddfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void ddfs </p>
<p>double ended (2-way) depth-first-search. Not yet implemented.</p>
<p>Advantages: faster searches for large graphs </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00379">379</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                               {</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Error Adjacency_List::ddfs(). This function has not &quot;</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot;yet been implemented. Sorry!\n&quot;</span>;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">throw</span> (std::runtime_error(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a18dd59802c4a04906aec8cc0703254e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18dd59802c4a04906aec8cc0703254e8">&#9670;&nbsp;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::dfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a> </p>
<p>Wrapper around _dfs (depth-first-search) algorithm that provides a cleaner user interface. See _dfs in the private section to view the algorithm implementation.</p>
<p>This function returns a path between two vertices if one exists. If no path exists, the dq output will be empty, which can be checked externally using dq.empty(). If more than one path exists, there is NO guarantee that the path found will be the shorted path.</p>
<p>Note: std::stack can be used in place of std::deque for less overhead however the deque comes with an iterator. this is an easy fix if needed later on. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00337">337</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                      {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it, src_it, dest_it;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        src_it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        dest_it = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(dest));</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="comment">// containter</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        std::deque&lt;T1&gt; dq;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="comment">// flag that indicates whether or not dest has been found</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="comment">// (ie a path has been found)</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="comment">// check that both vertices exist</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">if</span> (src_it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Error Adjacency_List::dfs(). Source vertex &quot;</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                      &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; does not exist!\n&quot;</span>;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            <span class="keywordflow">throw</span> (std::runtime_error(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dest_it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Error Adjacency_List::dfs(). Destination vertex &quot;</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                      &lt;&lt; dest &lt;&lt; <span class="stringliteral">&quot; does not exist!\n&quot;</span>;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            <span class="keywordflow">throw</span> (std::runtime_error(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        <span class="comment">// set all vertices to unidentified</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">for</span> (it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            it-&gt;second-&gt;indentified = <span class="keyword">false</span>;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="comment">// call the depth-first-search algorithm</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        <a class="code" href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">_dfs</a>(src, dest, dq, found);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">return</span> (dq);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_a3bdcdffd1d958c299effaf92662884f2"><div class="ttname"><a href="class_adjacency___list.html#a3bdcdffd1d958c299effaf92662884f2">Adjacency_List::_dfs</a></div><div class="ttdeci">void _dfs(T1 src, T1 dest, std::deque&lt; T1 &gt; &amp;dq, bool &amp;found)</div><div class="ttdoc">void _dfs(T1 src, T1 dest, std::deque&lt;T1&gt; &amp;dq, bool &amp;found) </div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00546">Adjacency_List.hpp:546</a></div></div>
<div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bd4579e85308ada2431895a71c5f7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd4579e85308ada2431895a71c5f7c7">&#9670;&nbsp;</a></span>displaygraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::displaygraph </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a> </p>
<p>Display graph to console. Parameter w determines setw formatting. Could overload &lt;&lt; operator </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00242">242</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                                  {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator        it;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator  adjIt;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="comment">// for all vertices</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">for</span> (it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="comment">// display vertex</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            std::cout &lt;&lt; std::setw(w) &lt;&lt; it-&gt;second-&gt;data &lt;&lt; <span class="stringliteral">&quot; |&quot;</span>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="comment">// for all edges in adjacency list</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end();</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                    ++adjIt) {</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                <span class="comment">// display edge</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                std::cout &lt;&lt; std::setw(w) &lt;&lt; adjIt-&gt;first &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            }</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            std::cout &lt;&lt; std::endl;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4940d2076901a50659ca83894b945218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4940d2076901a50659ca83894b945218">&#9670;&nbsp;</a></span>edgeexist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::edgeexist </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a> </p>
<p>Determine if an edge exists between two vertices. To prevent runtime errors this should ALWAYS be called before <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00188">188</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                                    {</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator adjIt;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordtype">bool</span> exist = <span class="keyword">false</span>;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="comment">// search source&#39;s adjacency list for edge</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end(); ++adjIt) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == dest) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                exist = <span class="keyword">true</span>;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keywordflow">return</span> (exist);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae810d0d613e5f2b233179b09a4fa0305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae810d0d613e5f2b233179b09a4fa0305">&#9670;&nbsp;</a></span>get_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::get_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T2&gt; <a class="el" href="class_adjacency___list.html#ae810d0d613e5f2b233179b09a4fa0305" title="std::set&lt;T2&gt; get_edges() ">get_edges()</a> </p>
<p>Returns a set storing all the existing edges </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00275">275</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                           {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        std::set&lt;T2&gt; edges;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator        it;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator  adjIt;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="comment">// for all vertices</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="keywordflow">for</span> (it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="comment">// for all edges in adjacency list</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end();</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                    ++adjIt) {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                <span class="comment">// insert edge</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                edges.insert(adjIt-&gt;first);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            }</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        }</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">return</span> edges;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2cbaca74a056c9b3d2ad6558fccdd696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbaca74a056c9b3d2ad6558fccdd696">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a2cbaca74a056c9b3d2ad6558fccdd696" title="std::set&lt;T1&gt; get_vertices() ">get_vertices()</a> </p>
<p>Returns a set storing all the existing vertices </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00301">301</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                              {</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        std::set&lt;T1&gt; vertices;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator        it;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="comment">// for all vertices</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        <span class="keywordflow">for</span> (it = <span class="keyword">this</span> -&gt; <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != <span class="keyword">this</span> -&gt; <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <span class="comment">// insert vertex</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            vertices.insert(it -&gt; second -&gt; data);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordflow">return</span> vertices;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb2da43c411ed0a239798a2a3c883f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2da43c411ed0a239798a2a3c883f24">&#9670;&nbsp;</a></span>getedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a> </p>
<p>Return edge between two vertices, if one exists. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00124">124</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator adjIt;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordtype">bool</span> exist = <span class="keyword">false</span>;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="comment">// search source&#39;s adjacency list for edge</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end(); ++adjIt) {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == dest) {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                exist = <span class="keyword">true</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        }</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="comment">// throw error if edge does not exist</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">if</span> (!exist) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: Adjacency_List::getedge(). Edge between &quot;</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                      &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; dest &lt;&lt; <span class="stringliteral">&quot; does not exist.\n&quot;</span>;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            <span class="keywordflow">throw</span> (std::runtime_error(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">return</span> (adjIt-&gt;first);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a59ad0070d2f6fcc2d3b5d86a616ff193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ad0070d2f6fcc2d3b5d86a616ff193">&#9670;&nbsp;</a></span>getneighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getneighbors </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::set&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a59ad0070d2f6fcc2d3b5d86a616ff193" title="std::set&lt;T1&gt; getneighbors(T1 src) ">getneighbors(T1 src)</a> </p>
<p>Return set of src's neighbors, if src exists. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00156">156</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                                    {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        std::set&lt;T1&gt; neighbors;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b">vertexexists</a>(src) == <span class="keyword">true</span>) {</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            <span class="comment">// local type definitions</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator adjIt;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;            <span class="comment">// search source&#39;s adjacency list for edge</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end(); ++adjIt) {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                neighbors.insert(adjIt -&gt; second -&gt; data);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Error Adjacency_List::getneighbors(). vertex &quot;</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                      &lt;&lt; src &lt;&lt; <span class="stringliteral">&quot; does not exist!\n&quot;</span>;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            <span class="keywordflow">throw</span> (std::runtime_error(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordflow">return</span> neighbors;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
<div class="ttc" id="class_adjacency___list_html_a5fef72d4ecb4cfa5438a653e1e58e91b"><div class="ttname"><a href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b">Adjacency_List::vertexexists</a></div><div class="ttdeci">bool vertexexists(T1 node)</div><div class="ttdoc">bool vertexexists(T1 node) </div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00212">Adjacency_List.hpp:212</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc9a43d2d171801e35c1f45ae6baca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9a43d2d171801e35c1f45ae6baca93">&#9670;&nbsp;</a></span>getnumv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getnumv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a> </p>
<p>Return the number of vertices. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00115">115</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                       {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">return</span> (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.size());</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a183c55c71c959b90164a334687a76cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c55c71c959b90164a334687a76cc2">&#9670;&nbsp;</a></span>getvertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a> </p>
<p>Return vertex from graph, if it exists </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00228">228</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                          {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(node));</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">return</span> (it-&gt;second-&gt;data);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a61efd38d84e8f713ea321d800bdca03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61efd38d84e8f713ea321d800bdca03f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a472ebd0a5b83448088959d1173fba710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472ebd0a5b83448088959d1173fba710">&#9670;&nbsp;</a></span>removeedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removeedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a> </p>
<p>Remove edge from graph. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00467">467</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                                     {</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(src));</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keyword">typename</span> std::list&lt;edge&gt;::iterator adjIt;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="comment">// search for and delete edge</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end();</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                ++adjIt) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;            <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == dest) {</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                it-&gt;second-&gt;adj.remove(*adjIt);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            }</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        }</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="comment">// if this graph is undirected, delete the &#39;other&#39; edge</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a>) {</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(dest));</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            <span class="keywordflow">for</span> (adjIt = it-&gt;second-&gt;adj.begin(); adjIt != it-&gt;second-&gt;adj.end();</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                    ++adjIt) {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                <span class="keywordflow">if</span> (adjIt-&gt;second-&gt;data == src) {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                    it-&gt;second-&gt;adj.remove(*adjIt);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                }</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        }</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
<div class="ttc" id="class_adjacency___list_html_a92ceab755c148a8f0bdb6f8c3ccfcc7f"><div class="ttname"><a href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">Adjacency_List::isdirected</a></div><div class="ttdeci">bool isdirected</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00525">Adjacency_List.hpp:525</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1794c310f08f59d85cb57b5d33caa667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1794c310f08f59d85cb57b5d33caa667">&#9670;&nbsp;</a></span>removevertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removevertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a> </p>
<p>Remove vertex, and all associated edges, from graph. </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00501">501</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                               {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="comment">// remove all edges from node</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        it = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(node));</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        it-&gt;second-&gt;adj.clear();</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="comment">// remove all edges to node</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        <span class="keywordflow">for</span> (it = this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.begin(); it != this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end(); ++it) {</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            <a class="code" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710">removeedge</a>(it-&gt;second-&gt;data, node);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        }</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        <span class="comment">// remove node</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keyword">delete</span> <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>[node];</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.erase(node);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
<div class="ttc" id="class_adjacency___list_html_a472ebd0a5b83448088959d1173fba710"><div class="ttname"><a href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710">Adjacency_List::removeedge</a></div><div class="ttdeci">void removeedge(T1 src, T1 dest)</div><div class="ttdoc">void removeedge(T1 src, T1 dest) </div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00467">Adjacency_List.hpp:467</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a463a0f885dd38f2d49b928bc12b1cdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a0f885dd38f2d49b928bc12b1cdcc">&#9670;&nbsp;</a></span>setdirected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::setdirected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isdirected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a> </p>
<p>Set the directedness of the graph. Default is undirected (false) </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00392">392</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                                      {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        this-&gt;<a class="code" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a> = <a class="code" href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">isdirected</a>;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_a92ceab755c148a8f0bdb6f8c3ccfcc7f"><div class="ttname"><a href="class_adjacency___list.html#a92ceab755c148a8f0bdb6f8c3ccfcc7f">Adjacency_List::isdirected</a></div><div class="ttdeci">bool isdirected</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00525">Adjacency_List.hpp:525</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5fef72d4ecb4cfa5438a653e1e58e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fef72d4ecb4cfa5438a653e1e58e91b">&#9670;&nbsp;</a></span>vertexexists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::vertexexists </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a> </p>
<p>Check if vertex is in graph </p>

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00212">212</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                               {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="comment">// local type definitions</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keyword">typename</span> vertexmap::iterator it  = (this-&gt;<a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.find(node));</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">if</span> (it == <a class="code" href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">vmap</a>.end()) {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">return</span> (<span class="keyword">false</span>);</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordflow">return</span> (<span class="keyword">true</span>);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    }</div><div class="ttc" id="class_adjacency___list_html_ab4154ab5baaf2c35eb12fdf4d2cc3887"><div class="ttname"><a href="class_adjacency___list.html#ab4154ab5baaf2c35eb12fdf4d2cc3887">Adjacency_List::vmap</a></div><div class="ttdeci">vertexmap vmap</div><div class="ttdef"><b>Definition:</b> <a href="_adjacency___list_8hpp_source.html#l00524">Adjacency_List.hpp:524</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a92ceab755c148a8f0bdb6f8c3ccfcc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ceab755c148a8f0bdb6f8c3ccfcc7f">&#9670;&nbsp;</a></span>isdirected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::isdirected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00525">525</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>

</div>
</div>
<a id="ab4154ab5baaf2c35eb12fdf4d2cc3887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4154ab5baaf2c35eb12fdf4d2cc3887">&#9670;&nbsp;</a></span>vmap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a> <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::vmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_adjacency___list_8hpp_source.html#l00524">524</a> of file <a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/bbercovici/GDrive/CUBoulder/Research/code/SBGAT/SbgatCore/include/SbgatCore/<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
